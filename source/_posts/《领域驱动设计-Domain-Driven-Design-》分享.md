---
layout: title
title: 《领域驱动设计(Domain-Driven Design)》分享
date: 2018-12-4 15:43:38
tags: [架构,技术分享]
categories: 技术
---

本来以为这个分享很好做，因为我在看《领域驱动设计--软件核心复杂性应对之道》这本书的时候，感受颇深，但真的在准备分享的时候，却发现不知道从哪里入手。

如果照着书的思路走，讲得肯定没有比书写得好，还啰嗦；网上找了下别人的分享，侧重点又各有不同。最后还是决定这次分享只讲两个方面，一个是是什么是领域驱动，一个是我在看领域驱动时，有较深感触的东西。

## 什么是领域驱动设计

> 领域驱动设计是一种**通过深入地将实现连接到领域模型**来满足复杂需求的软件开发方法。

### 领域模型(Domain Model)(核心)

**模型:** 模型大家都了解，比如世界地图就是一个简单的地球模型，模型被用来描绘人们所关注的现实或想法的某个方面。模型是一种简化，是对现实的解释--把与解决问题密切相关的方面抽象出来，忽略无关的细节。

**领域:** 基本上每个软件系统都是为了解决用户的某个问题，这些软件系统的问题区域就是软件的领域。比如电商、机票预订、货物托运等都称之为领域。

领域模型是对领域内的概念类或现实世界中对象的可视化表示，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。（百度百科）
**讲人话就是: 核心业务概念模型**

## 为什么引入领域驱动设计

> 传统设计缺陷

- 业务信息化困境
    - 开发人员与业务人员、不同开发人员之间沟通成本高
    - 业务逻辑分散，难以复用
- 失血模型
    - Model 层是只有 getter/setter 方法的失血模型，仅仅成为一个数据载体，而业务逻辑分散在各个分层中
    - 失血模型导致软件难以扩展和维护，违背面向对象思想，重新回到面向过程的编程老路，开发效率不高。

## 领域驱动设计该怎么做

~~**我也不知道该怎么做**~~

这一个问题没有办法好好地回答，因为我还没有完整地看完，也没有把理论付诸于实践，所以我能聊的只有一些自己比较有感触的地方。

### 通用语言

> 领域驱动设计的一个核心原则是使用一种基于模型的语言。

在建模过程中，软件开发者和领域专家(一般是需求方或产品经理)应该使用“通用语言(Ubiquitous Language)”进行沟通交流，在交流中由软件开发者提取领域知识，构建领域模型。

这一点我觉得很有价值。现在的开发流程基本都是由产品经理与需求方进行需求确认，并将需求整理成**需求文档(产品的语言)**。随后开发跟产品根据需求文档确定了开发任务，便开始**设计数据库(基于数据库的领域建模)**，最后完成**编码开发(开发的语言)**。

在整个流程里，各参与方使用了各自的语言，沟通成本高且容易导致信息在传递中失真。更可怕的是，当需求变更的时候，有很多意料不到的情况会发生，需求方以为只是一个很小的需求改动，在实现上却可能是推翻重来。

#### 一个不负责任的例子

需求方可能会说，我需要一个载具，我可以利用它上下班，于是需求文档里面就一条内容: **带我上下班的载具**。于是开发一看，这个跟我之前那个小米电动滑板车很像嘛，很快就倒腾出来了，顺利地给到测试，再过几天就上线量产了。

需求方突然又提了个需求，这载具能不能**帮我搬家**，应该很简单，之前是载人的载具，现在把容量变大点，够我放几张桌子椅子就好了。开发一看就辞职了。

假如产品与开发之间使用基于领域模型的通用语言进行沟通，产品会意识到需求的变更就是对领域模型的变更，对应的实现成本也能有点B数。(前提是，开发也要严格地实现领域模型)

> 同样的，除了产品与开发之间，不同的开发之间也要基于领域模型进行沟通，比如前端开发和后端开发之间。
> 所有开发要意识到，对代码的改动意味对模型的变更；产品要意识到，需求对应模型、模型对应实现

### 领域建模时思考问题的角度

> 一个不是很恰当的例子，我们要制作一个可以装水的杯子，所以制作出来的杯子必须是空的，这样才能容纳水。
> 建立领域模型时也要将用户置于模型之外,这样才能包容用户的需求。

**设计领域模型时不能以用户为中心作为出发点去思考问题,不能老是想着用户会对系统做什么;
而应该从一个客观的角度,根据用户需求挖掘出领域内的相关事物,思考这些事物的本质关联及其变化规律作为出发点去思考问题。**

如果以人所扮演的参与者角色在领域模型中占据主要位置，那么各个系统的领域模型将变得没有差别，因为软件系统就是一个人机交互的系统，都是以人为主的活动记录或跟踪。

比如论坛中如果以人为主导，那么领域模型就是:人发帖,人回帖,人结贴等。

这一点是我们经常会陷入的思维误区，我们收集用户需求，针对用户需求实现功能，我们的思路流程是，用户通过xxx操作可以完成xxx事。虽然这样也能把系统开发完，但是**系统的复杂度会越来越不可控**，系统不过是**各种功能的堆砌组合**，项目会充斥各种面条式的**面向过程的代码**。

以用户为中心来思考领域模型的思维只是停留在**需求的表面**,而没有挖掘出真正的**需求的本质**;我们在做领域建模时需要努力挖掘用户需求的本质,这样才能真正实现用户需求。

### 失血模型的问题

我们现在后端写的代码应该是属于`失血模型`，DAO负责数据的持久化，业务逻辑全部集中在service。

![](http://cdn.jsblog.site/15439067355693.jpg)

#### 一个例子 FROM 《盒马领域驱动设计、实践经验》

假如有父亲和儿子这两个表，那么实现大概会是下面这样:

```JAVA
public class Father {...}
public class Son {
    private String fatherId;
    public String getFatherId() {
        return fatherId;
    }
}    
```

现在如果父亲打了儿子一个耳光，那么这一个事件只能放到service去完成，service就像是一个上帝:

```JAVA
public class ManagerLikeGod {
    public void fatherSlapSon(Father father, Son son) {
        father.setPainOnHand(); //让父亲手疼
        son.setPainOnFace(); //让儿子脸疼
    }
}
```

这样子的代码虽然能够满足需求，即使用的是面向对象的语言，但是明显不是真正的面向对象，从实现上也不符合我们的认知。

假设我们的拥有一台内存无限大，永不宕机的机器，我们会怎么设计我们的系统。

我们不再需要数据库存储，所有数据保存在内存中，我们将从面向数据库设计中解脱出来，这就是`持久化无关设计(Persistence Ignorance)`。我们会使用面向对象的思想，基于程序本身来设计领域模型。

```JAVA
public class Father {
    //打儿子耳光是什么体验，父亲自己知道
    public void slapSon(Son son) {
        this.setPainOnHand();
        son.setPainOnFace();
    }
}
```

领域模型并不完成业务，每个domain object都是完成属于自己应有的行为（single responsibility），就如同人跑这个动作，person.run是一个与业务无关的行为，但这个时候manger或者service在调用 some person.run的时候可能完成的100米比赛这个业务，也可能是完成跑去送外卖这个业务。

![](http://cdn.jsblog.site/15439075501856.jpg)

## 最后

1. 并没有完整地将`领域驱动设计`该怎么做，也不是一篇文章就能讲完的。《领域驱动设计》这本书里有领域驱动设计的系统化方法，还有一些实践经验，可是代入感不强。对于这种方法类的知识，我觉得还是要在实践中去感受，才能有比较深的认知。
2. 不止是后端开发，网上也有领域驱动的前端实践，即使前端不使用领域驱动设计，也要能够了解后端的领域模型。了解相关的业务领域模型是整个项目的参与者必须要做的事。
3. 回到现实，领域驱动设计只是一套方法论，很可能会因为各种原因没办法真正推行，不止是领域驱动设计，还有很多东西都是一样，你可能觉得它好，可是你却没办法那样做。我的想法是，就算行为上选择了将就，也永远不要停止思考什么是对的事。



