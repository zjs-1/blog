---
title: 官网SSR内存泄漏排查
date: 2021-01-07 22:13:31
tags: [前端,DEBUG]
categories: 技术
---

## 背景

官网之前是用vue写的前端渲染的页面，为了进行SEO优化，对部分页面进行了后端渲染改造(改完后端渲染之后，还专门做了压测，增加了缓存机制)。

前阵子发现官网服务隔一段时间就会出现自动重启，得益于k8s容器的自动重启，没有影响到业务。但还是第一时间关闭了后端渲染的开关(为了应对开学典礼并发留的配置开关)，并通知相关业务方。

查看了官网容器的日志，发现是`OOM`(内存不足)导致的重启。于是留了一个开启了后端渲染的服务，第二天再次查看内存，发现内存保持在1G多没有下降(正常应该是几百MB)，基本确定是内存泄漏问题。

## 排查工具

### alinode

根据以往经验，还是先上`alinode`进行排查，但是那段时间也不知道是公司网络不给力还是`alinode`平台抽风，数据采集断断续续，无法得到准确的结果。

至于alinode怎么使用，之前已经在这篇文章讲过，就不再讲了(现在感觉alinode主要还是用于线上服务问题的定位)。
[使用alinode(Node.js 性能平台)定位内存泄漏](https://www.tapd.cn/35538527/markdown_wikis/show/#1135538527001000127)

### 本地调试

> heapdump + 内存信息打印 + ab(压测工具)

```javascript
let format = function(bytes) {
  return (bytes/1024/1024).toFixed(2)+'MB';
};
let showMem = function() {
  gc(); // 打印之前先进行手动gc，以查看更准确的状态
  let mem = process.memoryUsage();
  console.log('Process1: heapTotal '+format(mem.heapTotal) + ' heapUsed ' + format(mem.heapUsed) + ' rss ' + format(mem.rss));
};
setInterval(showMem, 3000);

// 提供一个接口用于生成内存快照
async getSnapshot() {
    gc();
    console.log('-----gc------');
    setTimeout(() => {
      console.log('heapdump');
      heapdump.writeSnapshot('/Users/zjs/Desktop/' + Date.now() + '.heapsnapshot', (function(err, filename) {
        console.log('dump written to', filename);
      }));
    }, 2000);
}
```

上面的代码比较简单，一个就是定时打印当前内存信息，便于观察，一个就是用于打印内存快照，打印出的快照可以在chrome的`devtools`里进行分析，使用方法同`alinode`。

这里有个小坑，`node`程序默认是没办法手动执行`gc`的，需要在启动的时候带上`--expose-gc`参数，官网项目的服务端用的是`egg`框架，尝试了好几种姿势，都没办法打开`expose-gc`。
最后不想花时间找对应的配置项了，直接进入到`node_modules/egg-cluster/lib/master.js`，在`forkAppWorkers`里给`cfork`函数多传了`execArgv: ['--expose-gc']`参数。

## 排查过程

### 将问题具体化

之前只是简单判断存在`内存泄漏`问题，至于是怎么泄漏的、泄漏严重程度这些都还不清楚。

既然初步推测是后端渲染导致的内存泄漏，那就先把后端渲染的缓存去掉，屏蔽掉干扰项。然后启动服务，观察控制打印的内存信息，等待内存稳定之后，发起后端渲染请求，等待内存稳定后，再次发起请求，多次重复。(因为这个动作后面重复用到，属于基本操作，后面简称`基操`)

重复进行上面的步骤可以总结出，第一次请求会导致内存大幅上升，大概50MB左右，后面每一次请求大概会增加6MB的内存。

第一次请求的内存上升应该是因为加载了一些后端渲染的第三方库，比如`jsdom`这些，不会随着请求增加而上升，可以做考虑。后面每次请求增加的6MB就是这一次主要要解决的问题了。

### eggOpenapiStats

一开始的思路是做多次内存快照进行对比，但是在实际操作中发现根本不可行，两次快照间多出来的堆内存根本看不出来是做什么用的，很多看起来都是vue底层的东西，像是在大海捞针。

还好初中的时候有认真上生物课，有学过对照实验。
直接把首页的所有元素都删了，只留了一个空白页，重复上面的`基操`，发现每次请求大概只增加0.1MB的内存。说明两个问题: 一个是内存泄漏主要存在于前端代码，另一个就是后端服务本身也有内存泄漏问题。

因为每次请求增加的内存都不多，不好观察，直接上`ab`(用法自己查)，一次进行一千次请求，在请求前后分别输出了内存快照。
![](http://cdn.jsblog.site/16100261924830.jpg)

这个东西看着有点眼熟，稍微查了下，问题出现在`eggOpenapiStats`，关闭了这个插件之后，剩下的0.1MB也消失了。(暂时关闭，立个flag，这个插件内存泄漏的问题后面要查，所有bt-egg服务都用到了)

### swiper

后端的问题处理完了，就接着查浏览器端的问题了，准备把东西一点点放出来尝试。在放出首页轮播图的时候，突然想起来之前在看`vue-awesome-swiper`的时候有看到SSR相关的使用方法。

这就是一道送分题了，翻文档，做处理，其实就是把`components`的写法改成`directive`的写法，快速搞定。

### $bus

弄完swiper，把其他东西都复原，再次进行`基操`，发现上面一通操作，大方向还是没变，每次请求依然有6MB的内存泄漏(心态炸了)。

继续做了N次对照实验，删模块=>构建=>基操，枯燥乏味的过程，最后发现问题的根源在`this.$bus.$on('toggleAsideMenu', this.toggleAsideMenu);`，就这样一句值6MB。

做了几个尝试:
1. 服务端环境下，不初始化真实的`this.$bus`，mock了`$on`、`$off`等方法
2. 在`mounted`的时候(服务端不会执行这个生命周期)，才执行`$on`
3. 组件`destroyed`的时候，执行`$off`

方案一二可行，最终选择了方案二，原则是尽量不动公共代码。方案三不行，服务端不会执行这个生命周期。

## 总结

到这一步内存泄漏的问题基本就全部找出来了，实际过程中还是走了很多弯路，怀疑过vuex的store，怀疑过vue-router，但最后都找不到证据，花费了不少时间。

总的来说，后端渲染要更加小心内存泄漏的问题，其实我们现在浏览器端的代码肯定是有内存泄漏问题的，只不过页面存在的生命周期很短，用户只要一刷新就归零重来了。
举个小小的例子，在页面里使用了setInterval，最后没有销毁掉，很多时候都是不会导致问题的。但是如果在后端渲染的时候，页面代码里有setInterval，那这个计时器就会一直存在服务端，而且没渲染一次就会增加一个定时器。




